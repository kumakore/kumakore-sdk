<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Android: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kumakore-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Android
   &#160;<span id="projectnumber">v0.6.2.0</span>
   </div>
   <div id="projectbrief">Every Platform. One Solution.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Android Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="http://kumakore.github.io/kumakore-sdk/images/diagram.jpg"  width="600px" align="middle"/>
</div>
<p>The Kumakore Service is a web service that provides RESTful API's to handle all the backend services; e.g., leaderboards, achievements, application, users, facebook, friends, inventory, matches, push, and datastore. The Kumakore SDK makes it easier to use the Kumakore Services both synchronously or asynchronously through the Kumakore Actions.</p>
<p>Client communication and control happens through Action objects that are mapped to specific Actions to the server. When sending data to the server, the client will create an Action object, set the appropriate data, and send the data either synchronously or asynchronously. When retrieving data from the server, the client will again create and send an action object, but the action will transfer the return data to the app or user data structures. The client will then retrieve the return data from here. Data is stored in either app data ( universal to the app such as achievements and leaderboards) or user data (specific to the user such as achievement progress) space. The important thing to remember is that server communication happens through these Action objects.</p>
<h2>Kumakore SDK - 2014 Q1 roadmap</h2>
<ul>
<li>add support for gifts</li>
<li>refactor Actions to match .NET SDK</li>
<li>improve KumakoreHttp Action lifecycle</li>
<li>enchance samples and tests for full coverage of Actions</li>
</ul>
<h2>Kumakore SDK startup and shutdown</h2>
<p>By now you should have read general documentation and know that an app will have an app key, dashboard version, and potentially an app version. The SDK, <a class="el" href="classcom_1_1kumakore_1_1_kumakore_app.html">KumakoreApp</a>, first needs to be initialized with these values </p>
<pre class="fragment">// startup
KumakoreApp app = new KumakoreApp(API_KEY, DASHBOARD_VERSION);

// load KumakoreApp state.
app.load();
</pre><p>From here you can begin calling app level data like user, leaderboards, achievements, and so on. During the application lifecycle, or before it ends, save the KumakoreApp state for loading in the future. </p>
<pre class="fragment">// shutdown
app.save();
</pre><p>It's also worth noting that <code>KumakoreApp.load/save</code> are default mechanisms to save and restore the core application state. These can be overridden and replaced with custom methods to fit the client's needs.</p>
<h2>Making Kumakore API calls</h2>
<p>Even using the action objects there are multiple ways of interacting with the Kumakore Service.</p>
<h3>1) Basic synchronous call</h3>
<p>Here's an example of a synchronous signup call. </p>
<pre class="fragment">ActionUserSignup signup = app.signup(email);
signup.sync();
if(signup.getCode() == StatusCodes.SUCCESS) {
    //Do something
}
</pre><p>A signup action object is created with an email. Then sync() makes a syncrhonous (blocking) call.</p>
<p>We could also have simplified this to </p>
<pre class="fragment">if(app.signup(email).sync() == StatusCodes.SUCCESS) {
    //Do something
}
</pre><h3>2) Using callbacks (interface)</h3>
<p>Alteratively the result of the API call could have been handled using a delegate passed to the sync function. Here is an example using signin.</p>
<pre class="fragment">app().signin(email, password).sync(new ActionUserSignin.IKumakore() {
    @Override
    public void onActionUserSignin(ActionUserSignin action) {
        if (action.getStatusCode() == StatusCodes.SUCCESS) {
            //Do something
        }
    }
});
</pre><p>The callback gets a signin action object where you can query the status of the action's execution. Of course a synchronous call isn't a very interesting use of a callback.</p>
<h3>3) Asynchronous call</h3>
<p>You can also make asynchronous (non-blocking) calls. This executes the API request in the background and allows the client application to continue (e.g. render a spinner). Here's an example using signin again with a callback. </p>
<pre class="fragment">app().signin(email, password).async(new ActionUserSignin.IKumakore() {
    @Override
    public void onActionUserSignin(ActionUserSignin action) {
        if (action.getStatusCode() == StatusCodes.SUCCESS) {
            //Do something
        }
    }
});
</pre><p>Aside form the using the async() call the difference is that the application will continue and when the request is complete the delegate will be executed.</p>
<h3>4) Asynchronous call without a delegate</h3>
<p>In general you want to provide a delegate to handle the return, but we can also handle this by querying the action itself </p>
<pre class="fragment">ActionUserSignup signup = app.signup(email);
signup.async();

while (signup.getCode() == StatusCodes.UNKNOWN) {
    //Draw spinner
}

if(signup.getCode() == StatusCodes.SUCCESS) {
    //Go to main menu
}
</pre><h3>5) The SDK uses on the builder pattern for various Actions to enable construction of complex objects.</h3>
<pre class="fragment">// simple params
app.getUser().update(usernameOrEmail, password).sync();
// builder params
app.getUser().update().setName(name).setEmail(email).setPassword(password).sync();
</pre><h3>6) Actions are a core structure</h3>
<p>You have now been exposed to the use of actions to communicate with the Kumakore service. Every server operation will have an individual action object. To stress the point again, the client retrieves data through the app or user data space and issues requests through actions.</p>
<p>In the following example, the application needs to list the app achievements. </p>
<pre class="fragment">for(AppAchievement aa : app.getAchievements().values()) {
    String name = aa.getName();
}
</pre><p>achievements() returns the internal list of achievements. However, when the app is first opened, the internal list is empty, so the application must request the achievements from the Kumakore service. </p>
<pre class="fragment">ActionAchievementGetApp a = app.getAchievements().get();
a.sync();
</pre><p>When the request returns, the action will handle the return data by copying it into the internal data structures. The next time the app prints the app achievements, there will be data.</p>
<p>Again the above call could be formed multiple ways. Here is an equivalent call. </p>
<pre class="fragment">app.getAchievements().get().sync();
</pre><p>Remember the sync() or async() happens on the action.</p>
<h3>7) Rety - execution count for Actions</h3>
<p>Actions make up a configuration of a request. Thus, once setup you can make more than one call to the action. That being said, we recommend creating a new Action for most cases. The following is an example where an action returned an errorCode other than success, and we want to retry the action. </p>
<pre class="fragment">app().platform().async(new ActionAppPlatform.IKumakore() {
    @Override
    public void onActionAppPlatform(ActionAppPlatform action) {
        if (action.getCode () == StatusCodes.SUCCESS) {
            //...
        } else if (action.getCode() == StatusCodes.APP_DASHBOARD_VERSION_INVALID) {
            // dashboard version is not valid. 
            // update KumakoreApp dashboard version, then retry?
            // the server dashboard version is stored in the action result
            // update the KumakoreApp dashboard version to match the result
            app.setDashboardVersion (action.getDashboardVersion ());

            //retry a few times?
            if (action.getExecutions() &lt; 3) {
                // No need to provide callback or other parameters again
                // because the action already associated the callback and params 

                // We need to reset the Action state to retry
                // true to reset the action state
                action.async(true); 
            }
        } else {
            //...
        }
    }
});
</pre><p>Even though you can execute an Action at any point, the results are held in the single instance of that Action. Thus, you should avoid additional sync/async operations for that Action at least until the callback is executed if you want to try again.</p>
<p>In this case, once the first call to async fails because of invalid dashboard version, then we rety that action.</p>
<h3>Further information</h3>
<p>At this point you should be familiar with interacting with the Kumakore SDK. More information about the SDK classes and calls can be found in the reference documentation.</p>
<h2>Inventory</h2>
<h3>1) Buying multiple items example</h3>
<p>Here's a more complex example of buying multple items. The SDK provides a purchase function that allows you to pass in a Dictionary of products. However, using the builder pattern, you can construct a complex action. </p>
<pre class="fragment">ActionInventoryPurchase a = app.getProducts().buyItem();
a.includeItem("laser", 1);
a.includeItem("shield", 2);
a.sync();
</pre><p>Which is also equivalent to </p>
<pre class="fragment">app.getProducts().buyItem().includeItem("laser"", 1).includeItem("shield", 2).sync();
</pre><h2>Matches</h2>
<p>Matches are the core of application gameplay, so this section will spend some time illustrating how matches are handled.</p>
<h3>1) Getting matches</h3>
<p>A user will have match lists stored in MatchCurrentList and MatchCompletedList objects corresponding to the user's active matches and completed mathces respectively. You can retrieve them through </p>
<pre class="fragment">OpenMatchMap open = app.getUser().getOpenMatches();
ClosedMatchMap closed = app.getUser().getClosedMatches();
</pre><p>Again, the lists will be empty if the state of the user's matches have not been retrieved from the server. In this case, actions are used to fetch data into these lists. </p>
<pre class="fragment">open.get().sync();
closed.get().sync();
</pre><p>Now, there will be data when you iterated through the match lists.</p>
<p>With current matches you can also drill down a level to matches that are your or your opponents turn.</p>
<h3>2) Creating a match</h3>
<pre class="fragment">open.createRandomMatch().async(new ActionMatchCreateRandom.IKumakore() {
    @Override
    public void onActionMatchCreateRandom(ActionMatchCreateRandom action) {
        if(action.getCode() == StatusCodes.SUCCESS) {
            //...
        }
    }
});
</pre><h3>3) Match status</h3>
<h3>4) Making a move</h3>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Mar 9 2014 22:11:48 for Android by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
